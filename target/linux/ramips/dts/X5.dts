//
// Device tree definition for Poray X5 and X6 routers.  
//
// This is free software, licensed under the GNU General Public License v2.
// See /LICENSE for more information.
//
// -- Luis Soltero <lsoltero@globalmarinenet.com>
// -- Michel Stempin <michel.stempin@wanadoo.fr> 
// -- Felix Kaechele <felix@fetzig.org>
//
//
// this files add support for the programmable switch on the side of the router labled 3G-DHCP
// 
//
// Notes on interfacing with the X5/X6 3G-DHCP switch
//
// there are two methods for interfacing with the 3G-DHCP/Switch. These are
// A. Button
// B. Polled
//
// To enable/disable the appropriate method search for COMMENT and comment/uncomppent the 
// appropriate definitions.  Note that both can not be enabled at the same time.  The switch
// can be defined as either a button or a exported GPIO but not both.
//
// A. Button Method
//
// the switch is defined as a button so events can be bound to it using hotplug.  The switch is bound to button BTN_0.
//
// GPIO /sys/class/gpio/usb-mode/value is used to map the X5 SD or USB port to the router.  When the ascii value '0' is
// writen to the gpio the router maps the internal TF/SD drive to the USB interface on the SoC.  When ascii value '1' is
// writen to the gpio the router maps the external USB port labled 3G-USB to the USB interfave on the SoC.
//
// To use the switch  you need to bind it to the BTN_0 button event in hotplug. Here is a /etc/config/system entry that will
// do that.
//
// config button
//        option button 'BTN_0'
//        option action 'released'
//        option handler 'echo 0 > /sys/class/gpio/usb-mode/value'
//
// config button
//        option button 'BTN_0'
//        option action 'pressed'
//        option handler 'echo 1 > /sys/class/gpio/usb-mode/value'
//
// this entry depends on hotplug and the 00-button script as defined here
// http://wiki.openwrt.org/doc/howto/hardware.button 
//
// FixMe:
// On boot up the system needs to probe the state of the switch to initialize the USB mode correctly. This can be done by
// parsing /sys/kernel/debug/gpio which returns
// GPIOs 0-23, 10000600.gpio:
// gpio-7   (x5:green:80         ) out hi
// gpio-9   (bat                 ) in  hi
// gpio-10  (reset               ) in  hi
// gpio-11  (x5:green:50         ) out hi
// gpio-12  (x5:green:20         ) out hi
// gpio-13  (x5:green:power      ) out lo
// gpio-14  (mode                ) in  lo
// gpio-18  (usb-mode            ) out lo
//
// gpio-14 has a value of lo (0) when the switch is set to DHCP and hi(1) when set to USB.
//
// B. Polled Method
//
// the switch state is exported as GPIO 14 with name "usb-switch".  It can be accessed using the following path
// /sys/class/gpio/usb-switch/value.  A value of 1 means that the switch is in 3G mode. A value of 0 means
// that DHCP is selected.  A script or program must be written which polls the state of the GPIO and then
// writes to GPIO 18 when the state changes.  Something like the following should work
//
// #!/bin/sh
// newstate=`cat /sys/class/gpio/usb-switch/value`
// curstate=""
// while [ 1 ] ; do
//    if [ "$currstate" -ne "$newstate" ]; then
//        $curstate=$newstate;
//        echo "$newstate" > /sys/class/gpio/usb-mode/value
//    fi;
//    sleep 2
//    newstate=`cat /sys/class/gpio/usb-switch/value`
// done
// 
// the script can be executed from /etc/init.d/

/dts-v1/;

/include/ "rt5350.dtsi"

/ {
	compatible = "X5", "ralink,rt5350-soc";
	model = "Poray X5";

	palmbus@10000000 {
		sysc@0 {
			ralink,pinmux = "i2c", "spi", "uartlite", "mdio", "sdram", "rgmii";
			ralink,gpiomux = "jtag";
			ralink,uartmux = "gpio";
			ralink,wdtmux = <1>;
		};

		gpio0: gpio@600 {
			status = "okay";
		};

		spi@b00 {
			status = "okay";
			m25p80@0 {
				#address-cells = <1>;
				#size-cells = <1>;
				compatible = "gd25q64";
				reg = <0 0>;
				linux,modalias = "m25p80", "gd25q64";
				spi-max-frequency = <10000000>;

		partition@0 {
			label = "u-boot";
			reg = <0x0 0x30000>;
			read-only;
		};

		partition@30000 {
			label = "u-boot-env";
			reg = <0x30000 0x10000>;
			read-only;
		};

		factory: partition@40000 {
			label = "factory";
			reg = <0x40000 0x10000>;
			read-only;
		};

		partition@50000 {
			label = "firmware";
			reg = <0x50000 0x7b0000>;
		};
			};
		};
	};

	ethernet@10100000 {
		status = "okay";
	};

	esw@10110000 {
		status = "okay";
		ralink,portmap = <0x2f>;
		ralink,led-polarity = <1>;
	};

	gpio-leds {
		compatible = "gpio-leds";
		power {
			label = "x5:green:power";
			gpios = <&gpio0 13 1>;
		};

		20 {
			label = "x5:green:20";
			gpios = <&gpio0 12 1>;
		};

		50 {
			label = "x5:green:50";
			gpios = <&gpio0 11 1>;
		};

		80 {
			label = "x5:green:80";
			gpios = <&gpio0 7 1>;
		};
	};

	gpio-keys-polled {
		compatible = "gpio-keys-polled";
		#address-cells = <1>;
		#size-cells = <0>;
		poll-interval = <20>;

		bat {
			label = "bat";
			gpios = <&gpio0 9 1>;
			linux,code = <0x211>;
		};

		reset {
			label = "reset";
			gpios = <&gpio0 10 1>;
			linux,code = <0x198>;
		};

//
// 3G-DHCP Switch BUTTON method
//
// Comment this out (thrugh END COMMENT) when using BUTTON Method
//		mode {
//			label = "mode";
//			gpios = <&gpio0 14 1>;
//			linux,code = <0x100>;
//		};
// END COMMENT
//
	};

        gpio_export {
                compatible = "gpio-export";
                #size-cells = <0>;

//
// 3G-DHCP Switch POLL Method
//
// Uncomment this out (through END COMMENT) when using the POLLED Method
                usb-switch {
                        gpio-export,name = "usb-switch";
                        gpio-export,input = <0>;
                        gpios = <&gpio0 14 0>;
                };
// END COMMENT
//

                usb-mode {
                        gpio-export,name = "usb-mode";
                        gpio-export,output = <0>;
                        gpios = <&gpio0 18 0>;
                };
        };

	wmac@10180000 {
		status = "okay";
		ralink,mtd-eeprom = <&factory 0>;
		ralink,led-polarity = <1>;
	};

	ehci@101c0000 {
		status = "okay";
	};

	ohci@101c1000 {
		status = "okay";
	};
};
